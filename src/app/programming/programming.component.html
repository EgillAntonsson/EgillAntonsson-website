<h1>TDD avatar health in C# via Unity</h1>
<h2>by Egill Antonsson, published on 2021 December 23</h2>
<p>TODO put links to LinkedIn and GitHub</p>

<h2>What is TDD ?</h2>
<p>
	TDD is a workflow approach and the heart of it is the <a href="http://www.jamesshore.com/v2/blog/2005/red-green-refactor">Cycle: RED / GREEN / REFACTOR</a>
</p>
<ol>
	<li><span class="redFail">RED:</span> Write a test that fails</li>
	<li><span class="greenPass">GREEN:</span> Get the test to Pass, with minimal effort (all tests passing)</li>
	<li><span class="greenRefactor">REFACTOR:</span> Clean up the structure and design (all tests passing)</li>
</ol>
<p>The cycle should focus on fulfilling a specific requirement on the object under test at a time,<br>
	cycling through to the point when confidence is gained that the production code is generic enough to handle all input cases.<br>
	At some interval you should stop and check if the code architecture on a wholistic level is still sound, and refactor if needed (all test passing).<br>
	Uncle Bob elaborates additional cycles around RED / GREEN / REFACTOR in his <a href="https://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html">The Cycles of TDD</a> post.
</p>

<h2>Why do TDD ?</h2>
<ul>
	<li>Ensures you'll have a passing test suite with high code coverage that runs fast (within seconds or minutes),<br>
		therefore you can clean the code without fear of breaking anything, thus always have confidence in the product quality, thus can ship it without fear.<br></li>
	<li>Writing tests first requires beneficial decoupling (that other testing strategies do not)</li>
	<li>Spend less time debugging.</li>
	<li>The tests act as accurate, precise, and unambiguous documentation at the lowest level of the system.</li>
</ul>
<p>
	There are also criticisms on TDD, e.g. the post <a href="https://dhh.dk/2014/tdd-is-dead-long-live-testing.html">TDD is dead. Long live testing.</a> but also responses to it, e.g the post <a href="https://blog.cleancoder.com/uncle-bob/2014/04/25/MonogamousTDD.html">Monogamous TDD</a>.
</p>

<h2>Does TDD work for all scenarios ?</h2>

<h3>Boundary layers</h3>
<p>
	Bulk of my work experience has centered around games (front-end game developer, developing shared systems for games)<br>
	and a big part of the (front-end) game is the graphic visuals and UI, user input, and sound.<br>
	Should those parts be unit tested via TDD ?<br>
	These parts can be described as layers close to the physical output/input boundaries.
	We should design these boundary layers to be <a href="http://xunitpatterns.com/Humble%20Object.html">Humble</a>.<br>
	by moving all the logic associated with them out into other modules for which we can easily write unit tests.<br>
	Bulk of the logic is likely the domain logic that should be in the domain layer and not be coupled with any boundaries (thus easily unit testable).<br>
	The edges of the boundary layers can be manually tested, e.g. seeing that the visuals drawn on screen properly.<br>
	There likely comes a point where automating testing the boundary layers provides value, and the <a href="https://martinfowler.com/articles/practical-test-pyramid.html">Test Pyramid</a> could guide you with that.
</p>

<h3>Untested and design-rusted code bases</h3>
<p>
	Some code bases have been developed for some time where unit tests were never written.<br>
	Such code bases leave the door open for bad code design to creep up along the way (although keeping up great design standard could prevent this).<br>
	One example could be that too many <a href="https://medium.com/aia-sg-techblog/why-singleton-pattern-is-considered-as-anti-design-pattern-c81dd8b7e757">Singletons</a> have been defined and used,<br>
	which feeds into the bigger issue of code being too <a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)">tightly coupled</a> / highly dependant.<br>
	By contrast a well and thoroughly tested code base pushes for, and to some degree enforces, the 'counter' good design<br>
	e.g <a href="https://effectivesoftwaredesign.com/2012/02/05/separation-of-concerns/">Separation of Concerns</a>, <a href="https://www.geeksforgeeks.org/solid-principle-in-programming-understand-with-real-life-examples/">Solid principles</a>.<br>
	One of the negative consequence of the design rusted and untested code base is that it's very hard to start writing <a href="https://livebook.manning.com/book/the-art-of-unit-testing-third-edition/chapter-1/v-6/125">good unit tests</a>, and even harder via TDD, 'that late in the game'.<br>
	<br>
	To get such a code base into a state where it's effortless to apply and continue with TDD,<br>
	it could be done with a gradual approach:
</p>
<ul>
	<li>Functional requirements (adding, improving, changing) continue to be done with some form of deadline pending</li>
	<li>Focus on adding <a href="https://livebook.manning.com/book/the-art-of-unit-testing-third-edition/chapter-1/v-6/125">great or good unit tests</a>, not necessarily with Test-First approach</li>
	<li>Fixing bugs provides good opportunity to apply TDD approach (write a test that fails due to the bug, fix the production code that passes the test)</li>
	<li>for other functionality, try to squeeze in a couple of tests</li>
	<li>Gradually refactor the design, ideally having sufficient tests to catch any breakages early</li>
	<li>Thus the test coverage gradually nudges upwards (going downwards is not acceptable).<br>
</ul>
<p>
	Another alternative	would be to dedicate a time period to focus only on refactoring the design, write <a href="https://livebook.manning.com/book/the-art-of-unit-testing-third-edition/chapter-1/v-6/125">great unit tests</a> thus improve the test coverage dramatically.
</p>
<h2>The chosen assignment: the avatar health</h2>
<p>
	I decided to do a short workshop about TDD at <a href="https://www.maginteractive.com">work</a> and for preparation I browsed the internet looking for a fitting assignment and I came across  <a href="http://infalliblecode.com/unity-tdd-1/">TDD in Unity - Part 1 post, by Charles Amat</a>, where his assignment is implementing the Life Gauge from a Zelda: Breath of the Wild game.<br>
	I thought it was a fitting assignment for the workshop, but I did not watch his series (as I was running out of preparation time).<br>
	 So instead I read through the <a href='https://zelda.fandom.com/wiki/Life_Gauge'>Life Gauge description on Zelda Wiki</a>
	(which was linked in the 'Part 1' post)<br>
	(and also played the game to refresh my memory).<br>
	I wrote down the Life Gauge behaviour from the user perspective (based on the wiki),<br>
	and then broke it down into list of requirement for the developer perspective<br>
	I focused first on the (non visual) domain logic, to implement all the requirements it should fulfill,<br>
	as TDD can fully and easily be applied on the domain layer.<br>
	Then the focus would shift to the visuals, where the value of TDD would likely dwindle the closer it got to the physical boundaries of the screen ('Boundary layers' section elaborates on this).<br>
	With this preparation I held the short workshop, where I screen shared TDD-ing the implementation from scratch,<br>
	and me and the participants collaboratively completed some of the domain logic requirements, when the time was up.<br>
	After the workshop, I wanted continue and complete the assignment.<br>
	I decided to watch the whole <a href="http://infalliblecode.com/unity-tdd-2/">TDD in Unity</a> series, which is in the format of <a href="https://en.wikipedia.org/wiki/Live_coding">live coding</a>.<br>
	I both enjoyed and learning from watching Charles Amat implementing via TDD the Life Gauge,<br>

</p>



<p>
	After getting the description that relates to the Heart Gauge from our hypothetical game designer,<br>
	and iterating it with her/him, we define terminology map, and the list of functional requirements:
</p>

<p>
	Mapping out separations of concerns and terms within the main 'Life Gouge' term.<br>
</p>
<table>
	<tr>
		<th>Model / Non-Visual Logic</th>
		<th>View / Visual (logic*)</th>
	</tr>
	<tr>
		<td class="center">
			Health
		</td>
		<td class="center">
			Heart Container
		</td>
	</tr>
	<tr>
		<td class="center">
				-
		</td>
		<td class="center">
			Heart (contains 4 Fractions)
		</td>
	</tr>
	<tr>
		<td class="center">
			Health Points
		</td>
		<td class="center">
			Heart Fraction
		</td>
	</tr>
</table>
<sup>* the View can have some logic, but it should only be about visual and minimal</sup>
<p>
	The want the code dependency to be minimal and one-way,<br>
	View can depend on Model (but not vice-versa).
</p>

<p>
	We focus first on Health model's functional requirements.<br>
	It can be broken into 3 parts:
</p>
<ol>
	<li>Health starting state</li>
	<li>Health taking damage</li>
	<li>Health healing</li>
</ol>
<p>
	In this blog post I'll focus on the first bulletin,<br>
	and I'll flesh it further out, as I iterate through the TDD cycles.<br>
	(I aim to tackle the other areas in following blog posts of this series).
</p>
<ul>
	<li>Health starting state</li>
		<ul>
			<li>Health Points starting value (12, which visually equals 3 Hearts)</li>
			<li>...</li>
		</ul>
</ul>

<hr>
<h3>Health Points starting value (12)</h3>
<p><span class="redFail">RED:</span>
	We define our test class and our first test.<br>
	The test is failing as the code does not even compile.
</p>
<pre><code [highlight]="test_1_Red"></code></pre>

<p><span class="greenPass">GREEN:</span> Let's make the test pass with a simple implementation.
</p>
<pre><code [highlight]="impl_1_Green"></code></pre>

<h4><span class="greenRefactor">REFACTOR</span></h4>

<p>Now it comes to mind that from a game design perspective,<br>
	it is good to be able to tweak the starting health points for game balancing<br>
	thus I refactor the value to be passed as parameter into the constructor.<br>
	<span class="outOfScope">A full-blown real-life system has accessible game balancing config<br>
	that is well integrated in the code base,<br>
	that would then use <span class="code">Health</span> class as designed (passing in value/s),<br>
	but that is out of scope.<br></span>
	<br>
	I name the passed parameter <span class="code">startingPoints</span>.<br>
	I also rename the property to <span class="code">CurrentPoints</span> to further clarify the logic:<br>
	starting health points is passed into constructor which sets the current health points.<br>
	<br>
	I also encapsulate t with private setter,<br>
	as I want to <a href="https://medium.com/swlh/the-importance-of-code-encapsulation-ce19efbcfe57"> encapsulate the implementation</a> as much as possible.<br>
	The only exposure should be for the class interface, that the tests will drive,<br>
	the will gradually be established through the TDD cycles.
</p>
<pre><code [highlight]="code_1_Refactor"></code></pre>

<hr>

<h3>Handle invalid starting points values</h3>
<p>
	Now it comes to mind that invalid starting point values can be passed in,<br>
	as our Link avatar should never start with less than 1 Health Points,<br>
	because otherwise he'd start up being dead (and what a sad game play that would be :) )<br>
	Thus I'll throw exceptions passed in value is invalid.<br>
	<span class="outOfScope">Invalid values should also be handled where they are defined<br>
	(e.g. in the previously mentioned game balancing config, which is out of scope).<br></span>
</p>

<h4><span class="redFail">RED</span></h4>

<pre><code [highlight]="test_2_Red"></code></pre>

<p>
	I deem I can use existing <span class="code">ArgumentOutOfRangeException</span> from <span class="code">System</span><br>
	that includes an informative error message for my case.<br>
	I chose the value 0 as it's on the invalid 'edge'. (as 1 is valid).
</p>

<h4><span class="greenPass">GREEN</span></h4>

<pre><code [highlight]="impl_2_Green"></code></pre>

<p>The <span class="greenPass">GREEN</span> implementation in this case,<br>
	is also the proper generic solution,<br>
	in other words I did <span class="greenPass">GREEN</span> and <span class="greenRefactor">REFACTOR</span> in one step.<br>
	<br>
	If using code would pass in value 0, the message of the thrown exception would be:
	<span class="code">System.ArgumentOutOfRangeException : Value '0' is invalid, it should be higher than '0'<br>
		Parameter name: startingPoints</span><br>
	<br>
	<br>
	I feel that no refactoring is needed in this cycle, as the code looks clean, so moving on.
</p>

<hr>

<p>As the implementation is very simple I am confident that it works for any passed-in values.<br>
	But let's test a few more values,<br>
	to demonstrate how one can do so in a clean and maintainable way.
</p>

<h4><span class="greenRefactor">Refactor</span></h4>

<p>Refactoring tests to add test cases where the value is close to the valid/invalid 'edge',<br>
	using <a href="https://docs.nunit.org/articles/nunit/technical-notes/usage/Parameterized-Tests.html">Parameterized Tests</a> with inline <a href="https://docs.nunit.org/articles/nunit/writing-tests/attributes/testcase.html">Test Case attribute</a>.
</p>
<pre><code [highlight]="test_3_Green"></code></pre>

<p>
	This runs in total 4 test cases and Unity Test Runner looks like this:
</p>
<ul>
	<li>HealthTest+PointsTest</li>
		<ul>
			<li>HasStartingValue
				<ul>
					<li>&#9989; HasStartingValue(12)</li>
					<li> &#9989; HasStartingValue(1)</li>
				</ul>
			</li>
			<li>ThrowsError_WhenStartingValueIsInvalid
				<ul>
					<li>&#9989; ThrowsError_WhenStartingValueIsInvalid(0)</li>
					<li>&#9989; ThrowsError_WhenStartingValueIsInvalid(-1)</li>
				</ul>
			</li>
		</ul>
</ul>

<hr>

<p>This concludes the first bulletin on our requirement list, and this blog post.<br>
	I aim to continue with the list in following blog posts, so let's end it with the viewing the list.
</p>

<ul>
	<li>Health starting state</li>
		<ul>
			<li>Health Points starting value &#9989;</li>
			<li>Handle invalid starting value for Health Points &#9989;</li>
		</ul>
	<li>Health taking damage</li>
		<ul>
			<li>... to be fleshed out</li>
		</ul>
	<li>Health healing</li>
		<ul>
			<li>... to be fleshed out</li>
		</ul>
</ul>
