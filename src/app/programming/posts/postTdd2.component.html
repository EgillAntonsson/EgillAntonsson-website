<h1>{{post.seriesTitle}}</h1>
<h2>{{post.title}}</h2>
<small>by Egill Antonsson, published on {{post.dateYear}} {{post.dateMonth}} {{post.dateDay}}</small>

<h2>My short workshop</h2>
<p>
	I decided to do a short workshop about TDD at <a href="https://www.maginteractive.com">work</a> and for preparation I browsed the internet looking for a fitting assignment and I came across <a href="http://infalliblecode.com/unity-tdd-1/">TDD in Unity - Part 1 post, by Charles Amat</a>, where his assignment is implementing the Life Gauge from a Zelda: Breath of the Wild game,<br>
	and I thought it was a good and fitting assignment for the workshop.<br>
	 So I read through the <a href='https://zelda.fandom.com/wiki/Life_Gauge'>Life Gauge description on Zelda Wiki</a>
	(which was linked in the 'Part 1' post), and also played the game a bit, focusing on the Life Gauge.<br>
	But I did not go through the 'TDD in Unity' series, as I was running out of preparation time.<br>
	My order both in my preparations and then to go through in the workshop:<br>
</p>
<ol>
	<li>Write down the Life Gauge behavior from the user perspective (based on the wiki and my experience)</li>
	<li>Break it down and filter into a list of requirements for the developer perspective</li>
	<li>Focus first on the (non visual) domain logic and implement all the requirements it should fulfill,<br>
		as TDD can fully and easily be applied on the domain layer.</li>
	<li>Afterwards the focus would shift to the visuals,<br>
		where the value of TDD potentially would dwindle the closer I got to the physical boundary of the screen ('Boundary layers' section above elaborates on this).</li>
</ol>
<p>
	With this I held the short workshop where I screen shared TDD-ing the implementation from scratch,<br>
	and I and the participants collaboratively completed some of the domain logic requirements, when the time was up.<br>
</p>

<h2>Comparing approaches of the assignment</h2>
<p>
	After the workshop, I was curious how Charles Amat solved it,<br>
	so I watched on YouTube the whole <a href="http://infalliblecode.com/unity-tdd-2/">TDD in Unity</a> series.<br>
	I both enjoyed and learned some things watching Charles Amat <a href="https://en.wikipedia.org/wiki/Live_coding">live coding</a> and implementing the Life Gauge<br>
	and his end result solution is good, and I thank Charles for his work.<br>
	but I noticed that his focus order differed from mine, as he:<br>
</p>
<ol>
	<li>Starts planning how he would go about creating the heart container in Unity, from a graphical UI perspective</li>
	<li>Starts TDD-ing logic close to the graphical UI</li>
	<li>Ends with TDD-ing the domain logic, the Player Health in <a href="http://infalliblecode.com/unity-tdd-7/">Part 7</a> and 8</li>
	<li>The requirements on the domain logic are very simple and do not cover close to all the player health requirements of <i>Zelda: Breath of the Wild</i></li>
</ol>

<h3>TDD-ing the same assignment, but with my focus order</h3>
<p>
	This is why I wanted to do a blog post series with the same assignment:<br>
	implement Avatar Health, based on <i>Zelda: Breath of the Wild</i>, but with my focus order:<br>
	Focusing first on the domain logic, and implement all the Avatar Health requirements of <i>Zelda: Breath of the Wild</i>.<br>
	When focusing on the domain logic, there will only be C# and .NET (though I'm using Unity and running tests via its Test Runner),<br>
	as there should be no Unity visual specific code in the domain layer.<br>
	When the focus later goes to the visuals, then there will be some Unity visual specific code.<br>
	The visual implementation will likely be similar to the <a href="http://infalliblecode.com/unity-tdd-1/">TDD in Unity series</a>,<br>
	and I might even reference it heavily, instead of reinventing the wheel for that part.
</p>

<h3>The Life Gauge behavior from the user perspective</h3>
<p>
	The below list is based on the <a href='https://zelda.fandom.com/wiki/Life_Gauge'>Life Gauge description on Zelda Wiki</a>,<br>
</p>
<ul>
	<li><b>Definition and start state</b></li>
	<li>The Life Gauge measures Link's current amount of health</li>
	<li>Health is visually represented in the form of Hearts, and they are in fractions of four</li>
	<li>The Life Gauge starts with 3 Hearts</li>
	<br>
	<li><b>Taking damage and dying</b></li>
	<li>Whenever Link (the avatar) takes damage, he will lose a certain amount of Heart fractions equal to the damage taken.<br>
		When Link loses all of his Hearts, the game ends.</li>
	<li>Link will take at least a quarter of a Heart of damage from any attack</li>
	<li>Some enemies may do more damage in one hit than Link has health.<br>
		As long as Link's Life Gauge is full, he is protected from any attack that would instantly kill him,<br>
		and will instead be left alive with a quarter Heart remaining.<br>
		However, this has limitations: if the damage is more than five Hearts above Link's maximum health, he will still die</li>
	<br>
	<li><b>Health Replenishing and maximum</b></li>
	<li>Link's Life Gauge can be replenished by:<br>
		picking up recovery Hearts,<br>
		drinking recovery Potions<br>
		or by resting while Sitting or Sleeping.
		</li>
	<li>The Life Gauge can be extended to a total of 30 Hearts</li>
	<br>
	<li>The Life Gauge can be temporarily extended by consuming certain Foods that grant Link yellow temporary Hearts.<br>
		These Hearts are lost when Link takes damage and cannot be recovered.</li>
</ul>

<h3>Domain / Visual mapping of <i>Life Gauge</i></h3>
<table>
	<tr>
		<th>Domain Layer / Model</th>
		<th>Visual Layer / View</th>
	</tr>
	<tr>
		<td class="center">
			Avatar Health
		</td>
		<td class="center">
			Heart Container
		</td>
	</tr>
	<tr>
		<td class="center">
				-
		</td>
		<td class="center">
			Heart (contains 4 Fractions)
		</td>
	</tr>
	<tr>
		<td class="center">
			Health Points
		</td>
		<td class="center">
			Heart Fraction
		</td>
	</tr>
</table>
<p>
	This is a helpful separation of concerns for the code implementation (and team communication):<br>
	<br>
	Heart Container (with its Hearts and fractions) is a specific visual representation of the Avatar Health, the domain.<br>
	<br>
	We want the code coupling to be low / dependency to be minimal and one-way,<br>
	The view can depend in some way on the model (but not vice-versa).<br>
	<br>
	I (or the team's game designer / artist) might decide to change the visually representation to a health bar (or simply a number)<br>
	and with this separation of concern:
<ul>
	<li>As the model is not dependent on the View, the Model will be unaffected</li>
	<li>The model code terminology will be unaffected.</li>
</ul>
<p>
	I might end up having more than one visual representations simultaneously to fully illustrate this.<br>
	It is common in game UI two have more than one visual representation of the same domain (although not for avatar's health specifically).
</p>
