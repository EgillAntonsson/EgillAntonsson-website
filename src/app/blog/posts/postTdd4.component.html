<h1>{{post.seriesTitle}}</h1>
<h2>{{post.title}}</h2>
<div class="byAndDate">
	<small>by Egill Antonsson, published on {{post.dateYear}} {{post.dateMonth}} {{post.dateDay}}</small>
</div>

<h2>The first Taking Damage requirement</h2>
<p>
	Let's recap the first requirement under <i>Taking Damage and Dying</i> from the user perspective<br>
	(whole <i>Life Gauge behavior</i> list is in <a href="./blog/tdd-health/part2">Part 2</a>):
</p>
<ul class='list'>
	<li>Whenever Link takes damage he will lose a certain amount of Heart fractions<br>
		equal to the damage points taken (always losing at least 1 fraction)</li>
</ul>
<p>
	Let's filter and transform this into a requirement that's focused only on the domain (as GUI will be done later):
</p>
<ul class="list">
	<li>Avatar will lose Health <code>CurrentPoints</code> equal to Damage Points taken (always losing at last 1 Health Point)</li>
</ul>

<h2>TDD cycling Taking Damage</h2>

<h3><span class="redFail">RED</span></h3>
<p>
	I start by writing the test.<br>
	The domain model focus will be a new method named <code>TakeDamage</code>,<br>
	Thus the write a nested test class with same name at the bottom,<br>
	and within it write the test case <code>CurrentPointsDecrease</code> (I elaborate on my naming convention in <a href="./blog/tdd-health/part3">Part 3</a>),<br>
	that fails as the code does not compile (<code>TakeDamage</code> not yet written).
</p>
<pre><code [highlight]="test_1_Red"></code></pre>
<p>
	Just to test not always the same starting value, I use <code>11</code> here (instead of <code>12</code>).
</p>

<h3><span class="greenPass">GREEN</span> -> <span class="greenRefactor">REFACTOR</span></h3>
<p>Let's make the test pass with a simple implementation of <code>TakeDamage</code>.
</p>
<pre><code [highlight]="impl_1_Green"></code></pre>
<p>
	I'm confident that the implementation is the proper generic solution for this requirement,<br>
	and it was also easy to come up with, and thus does not need additional steps to generalize.<br>
	<br>
	I feel that no other refactoring is needed in this cycle,<br>
	but I notice that invalid values can be passed in for <code>damagePoints</code> parameter,<br>
	so let's do a cycle for that.
</p>

<h2>Handle invalid <span class="code">damagePoints</span> values</h2>

<h3><span class="redFail">RED</span></h3>
<p>
	I start by writing the test.<br>
	A minus value for <code>damagePoints</code> is clearly invalid but what about <code>0</code> ?<br>
	I conclude that <code>0</code> is also invalid,<br>
	as an outside 'damage checker and calculator' logic should take care of this earlier<br>
	and not process further when <code>damagePoints</code> is <code>0</code> or less (thus <code>TakeDamage won't be called)</code>.<br>
	This also makes the design streamlined as it ensures that<br>
	<code>CurrentPoints</code> will always decrease on <code>TakeDamage</code> call.<br>
	<br>
	This will be similar test to the existing <code>ThrowsError_WhenStartingPointsIsInvalid</code> test<br>
	but now the <i>entry point</i> is method <code>TakeDamage</code>,<br>
	and thus it will be under nested class <code>TakeDamage.</code>
</p>
<pre><code [highlight]="test_2_Red"></code></pre>
<p>
	The number I pass into the constructor does not matter to this test, and thus is not a <i>TestCase</i> parameter.
</p>

<h3><span class="greenPass">GREEN</span></h3>
<p>Let's make the test pass with a simple implementation.<br>
	I duplicate the exception throwing code from the constructor and simply fix the parameter to <code>damagePoints</code>.<br>
	(knowing that I'll refactor this code smell right away in the next step).
</p>
<pre><code [highlight]="impl_2_Green"></code></pre>

<h3><span class="greenRefactor">REFACTOR</span></h3>
<p>
	I refactor the duplicated code smell away,<br>
	and I run all the tests as needed during it, to verify I haven't broken anything.<br>
	After some time the implementation feels fully refactored for the requirements:
</p>
<pre><code [highlight]="impl_2_Refactor"></code></pre>
<p>
	Having <code>lowestValidValue</code> as sent in parameter for method <code>ValidatePoints</code><br>
	makes the method easy to reuse, if another case comes later with different  <code>lowestValidValue</code>.<br>
	<br>
	I run the tests in the end to verify everything works.<br>
	Below is the whole <code>HealthTest.cs</code>, along showing last run in the Test Runner:
</p>
<pre><code [highlight]="test_final"></code></pre>
<figure>
	<img src="../assets/images/blog/tdd/HealthTest-ThrowsErrorRefactoring.PNG" alt="Unity Test Runner: after refactoring 'ThrowsError' code" title="Unity Test Runner: after refactoring 'ThrowsError' code" class="imageSmallText">
	<figcaption>
		Unity Test Runner: after refactoring 'ThrowsError' code
	</figcaption>
</figure>

<h2>Concluding this part</h2>

<p>This concludes these requirements and this part.<br>
	The code and Unity project is in this <a href="https://github.com/EgillAntonsson/tdd-avatar-health-in-unity">GitHub repo</a><br>
	I aim to continue with the requirements and the implementation in later blog posts.
</p>

