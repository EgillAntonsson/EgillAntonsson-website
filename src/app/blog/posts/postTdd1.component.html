<!-- <h1>TDD-ing Avatar Health in C# via Unity</h1> -->
<h1>{{post.seriesTitle}}</h1>
<h2>{{post.title}}</h2>
<div class="byAndDate">
	<small>by Egill Antonsson, published on {{post.dateYear}} {{post.dateMonth}} {{post.dateDay}}</small>
</div>

<h2>What is TDD ?</h2>
<p>
	TDD is an acronym for <i>Test Driven Development</i><br>
	and is a workflow discipline / approach for developers, focused on <b>when</b> to write unit tests,<br>
	and the heart of it is the <a href="http://www.jamesshore.com/v2/blog/2005/red-green-refactor">RED / GREEN / REFACTOR cycle:</a>
</p>
<ol class="list">
	<li><span class="redFail">RED:</span> Write a test that fails</li>
	<li><span class="greenPass">GREEN:</span> Get the test to pass, with minimal effort</li>
	<li><span class="greenRefactor">REFACTOR:</span> if needed: generalize the solution, clean up the structure / design / <a href="https://pragmaticways.com/31-code-smells-you-must-know/">code smells</a> (all tests passing)</li>
</ol>
<p>The cycle should focus is on fulfilling a requirement on the Subject under Test (SUT), one at a time,<br>
	repeating it until you are confident that the production code has become generic enough to handle all input cases. (with test becoming more specific).<br>
	At some interval you should stop and evaluate if the design of the overall system is sound,<br>
	and refactor if needed (all test passing).<br>
	This is my summarization of Uncle Bob's post <a href="https://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html">The Cycles of TDD</a> and other sources.<br>
	(Bob defines additional cycles around RED / GREEN / REFACTOR in his post).
</p>

<h2>What is a good Unit Test ?</h2>
<p>
	We should make sure we always write good unit tests (as opposed to bad and brittle),<br>
	and test code should be kept as clean as the production code. (REFACTOR step in TDD applies to both)<br>
	Here are definitions from Roy Osherove in The Art of Unit testing, 3rd edition:<br>
</p>

<h3><a href="https://livebook.manning.com/book/the-art-of-unit-testing-third-edition/chapter-1/v-6/25">Unit of Work definition</a></h3>
<p>
A unit of work is the sum of actions that take place between the invocation of an entry point<br>
up until a noticeable end result through one or more exit points.<br>
The entry point is the thing we trigger.<br>
Given a publicly visible function, for example:
</p>
<ul class="list inline">
	<li>The function's body is all or part of the unit of work.</li>
	<li>The function's declaration and signature are the entry point into the body.</li>
	<li>The resulting outputs or behaviors of the function are its exit points.</li>
</ul>

<h3><a href="https://livebook.manning.com/book/the-art-of-unit-testing-third-edition/chapter-1/v-6/193">Good Unit Test definition</a></h3>
<p>
A unit test is an automated piece of code that invokes the unit of work<br>
through an entry point, and then checks one of its exit points.<br>
It can be written easily and runs quickly.<br>
It's trustworthy, readable & maintainable.<br>
It is consistent as long as the production code we control has not changed.
</p>

<h2>Why do TDD ?</h2>
<p>Here is a my non-exhaustive list in order of priority:</p>
<ol class="list">
	<li>Ensures you'll have passing test suite with high production code coverage<br>
		that runs fast (each case less than 0.1 sec) so you get feedback early,<br>
		thus you can clean the code fast and continuously without fear of breaking it,<br>
		thus have high confidence in the shipped product quality.<br></li>
	<li>It pushes for code good design, e.g <a href="https://effectivesoftwaredesign.com/2012/02/05/separation-of-concerns/">Separation of Concerns (SoC)</a>,<br>
	and code to be low <a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)">coupled</a> / have few dependencies.<br>
	<li>Should push the production code to be low <a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)">coupled</a> / hav e few dependencies,<br>
		with each unit having a clean interface (focused on the requirements),<br>
		which should benefit the design and maintainability</li>
	<li>The tests are accurate and up-to-date (developer focused) documentation<br>
		of the behavior of the tested units.</li>
	<li>Less time spent in the debugger</li>
</ol>
<p>
	There are also criticisms on TDD, e.g. the post <a href="https://dhh.dk/2014/tdd-is-dead-long-live-testing.html">TDD is dead. Long live testing</a>,<br>
	and discussion about it, e.g. the YouTube series <a href="https://www.youtube.com/watch?v=z9quxZsLcfo">Is TDD dead ?</a><br>
	and responses to it, e.g the post <a href="https://blog.cleancoder.com/uncle-bob/2014/04/25/MonogamousTDD.html">Monogamous TDD</a>.
</p>

<h2>Is TDD suitable for all areas / situations ?</h2>

<p>
	Although I have over a decade long <a href="https://www.linkedin.com/in/egillantonsson">developer work experience</a><br>
	mainly as front-end game developer, and shared game systems developer.<br>
	I've gained some experience in writing good unit tests (and 'not so good' to start with),<br>
	but to a lesser degree using TDD, thus I'm currently not very seasoned in using TDD,<br>
	but I'm open to use it more and get more experienced with it (writing this blog series is part of it).<br>
	Why I haven't used TDD more often already, is to some degree because when facing many 'hard to influence' deadlines, I've opted for 'just get it done in time' mindset.<br>
	But more often than not it's because I'm working in areas / situations that are not so suited or easy to use TDD.<br>
	Below are the main areas / situations (and couple of ways to use TDD more effectively where / when applicable).
</p>

<h3>Boundary layers</h3>
<p>
	A big part of a game is the graphic user interface (UI) and visual effects, user input and sound,<br>
	should these parts be unit tested ?<br>
	<br>
	These parts can be described as layers close to the physical output/input boundaries (e.g. screen, speaker)<br>
	The design can be driven to make these boundary layers thin and <a href="http://xunitpatterns.com/Humble%20Object.html">humble</a>,<br>
	focusing on the responsibility of the boundary (e.g. disable/enable button), and extracting other logic into other modules that can be easily tested.<br>
	<br>
	It's likely that the logic to extract is in fact the <a href="https://enterprisecraftsmanship.com/posts/what-is-domain-logic/">Domain Logic</a> (a.k.a Business Logic),<br>
	code that makes decisions that have to do with the game requirements (business)<br>
	 and thus belongs to the <a href="https://enterprisecraftsmanship.com/posts/domain-model-isolation/">Domain Model</a> and then should be moved there<br>
	(the Domain Model should not depend on any boundaries, thus be easily unit testable).<br>
	<br>
	The edges of the boundary layers can be manually tested, e.g making sure the button displays properly on the screen.<br>
	If boundary bugs begin slipping into the production as the project grows,<br>
	then it's time to replace some of the manual testing effort with automated tests (e.g integration and/or UI tests).<br>
	The <a href="https://martinfowler.com/articles/practical-test-pyramid.html">Test Pyramid</a> could be a guide for that process.
</p>

<h3>Legacy Code</h3>
<p>
	Legacy code means here a code that has been developed for some time<br>
	and is already 'working' (for most common scenarios / most of the time),<br>
	is hard to read and figure out it's behavior,<br>
	has some bad code design that has crept in with time, (e.g. high coupling / high dependency)<br>
	and has no tests or few bad ones / very low test coverage.<br>
	<br>
	When legacy code is touched (and at some point it needs to)<br>
	there is high risk of setting the system into an unknown state of stability,<br>
	thus it is hard to change it and having the confidence that the change did not break anything.<br>
	(at best a long thorough manual testing effort verifies the change, at worst a bug slips into production).<br>
	<br>
	It's possible to prevent bad code design to creep up,<br>
	by upholding great design principles and continuos code cleaning, without unit writing tests.<br>
	But using TDD complements this prevention very well (see <i>Why do TDD ?</i> section above)<br>
	<br>
	One of the negative consequence of legacy code is<br>
	that it's very hard to write good unit tests<br>
	(e.g. likely need a lot of <a href="http://xunitpatterns.com/Mocks,%20Fakes,%20Stubs%20and%20Dummies.html">Test Doubles</a> to mute dependency interference, which is both time costly and not ideal).<br>
	Legacy code needs to be carefully improved into a better state<br>
	before the developers can use TDD effortlessly.<br>
	Improving legacy code is a big topic thus I'll leave it here<br>by referencing a book:
	<a href="https://www.goodreads.com/book/show/44919.Working_Effectively_with_Legacy_Code">Working Effectively with Legacy Code</a>,<br>
	and a post: <a href="https://devon.global/starting-tdd-legacy-code/">Starting TDD with legacy code</a>.
</p>
