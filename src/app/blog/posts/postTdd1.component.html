<h1>{{post.seriesTitle}}</h1>
<h2>{{post.title}}</h2>
<div class="byAndDate">
	<small>by Egill Antonsson<br>
		published on {{publishedDateToString}}<br>
	</small>
	<small *ngIf="hasUpdatedDate">
		updated on {{updatedDateToString}}
	</small>
</div>
<h2>Introduction</h2>
<p>
 Test-Focused Development is a broad term that encompasses a variety of methodologies that prioritize writing unit tests as a significant part of the development process. The main methodology is Test-Driven Development (TDD) that focuses on <i>when</i> to write unit tests, thus there are 2 underlying and skills needed to be applied as well to reap the benefits of TDD (and more broadly Test-Focused Development): Writing <b>Good</b> unit tests and designing <b>Good</b> architecture. Let's go through these 3 skills.
</p>

<h2>Good unit test</h2>
<p>
	A good unit test should focus on a specific observable requirement on the SUT (Subject / Unit Under Test). The book <a href="https://livebook.manning.com/book/the-art-of-unit-testing-third-edition" target="_blank">The Art of Unit testing, 3rd edition</a> by <b>Roy Osherove</b> focuses on writing good unit tests and the below definitions are from the book (for him the word 'unit' in unit testing stands for 'unit of work' or a 'use case').
</p>
<h3><a href="https://livebook.manning.com/book/the-art-of-unit-testing-third-edition/chapter-1/v-10/38">Unit of work</a></h3>
<p>
A <i>unit of work</i> is the sum of actions that take place between the invocation of an <i>entry point</i> (what is triggered) up until a noticeable end result through one or more <i>exit points</i>.
</p>
<p>
	Given a publicly visible function:
</p>
<ul class="list inline">
	<li>The function's body is all or part of the <i>unit of work</i>.</li>
	<li>The function's declaration and signature are the <i>entry point</i> into the body.</li>
	<li>The resulting outputs or behaviors of the function are its <i>exit points</i>.</li>
</ul>
<h3><a href="https://livebook.manning.com/book/the-art-of-unit-testing-third-edition/chapter-1/v-10/137">A Good unit test</a></h3>
<h4>A Good automated test (not just unit test)</h4>
<ul class="list">
	<li>Should be easy to read and understand the intent of the author and to write.</li>
	<li>Should be consistent in its results (it always returns the same result if you don't change anything between runs).</li>
	<li>Should be useful and provide actionable results.</li>
	<li>Anyone should be able to run it at the push of a button.</li>
	<li>When it fails, it should be easy to detect what was expected and pinpoint the problem.</li>
</ul>
<h4>Good unit test</h4>
<ul class="list">
	<li>Should run quickly.</li>
	<li>Should have full control of the code under test.</li>
	<li>Should be fully isolated (runs independently of other tests).</li>
	<li>Should run in memory without requiring system files, networks, databases...</li>
	<li>should be as synchronous and linear as possible (no parallel threads if we can help it).</li>
</ul>
<h4><a href="https://livebook.manning.com/book/the-art-of-unit-testing-third-edition/chapter-1/v-10/206" target="_blank">Good unit test summarized</a></h4>
<p>
	A unit test is an automated piece of code that invokes the unit of work through an entry point, and then checks one of its exit points. It can be written easily and runs quickly. <b>It's trustworthy, readable & maintainable. It is consistent as long as the production code we control has not changed.</b>
</p>

<h2>Good code architecture</h2>
<p>
	Designing good code architecture is a fundamental skill on provides good of value on its own, but also needs to be applied to reap the benefits of TDD (and more broadly Test-Focused Development). This applies to principles from both Object Oriented programming and <a href="https://livebook.manning.com/book/functional-programming-in-scala-second-edition/" target="_blank">Functional programming</a> (for example function with side effects complicates / limits testability).
</p>
<p>
	There is a correlation also in the other direction as TDD, done in the <b>Good</b> way, pushes for  good code code design and maintainability (for both the production and the test code), for example:
</p>
<ul class="list inline">
	<li><a href="https://effectivesoftwaredesign.com/2012/02/05/separation-of-concerns/">Separation of Concerns (SoC)</a></li>
	<li>code should be low <a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)">coupled</a> / have minimal dependencies</li>
	<li>each unit should have a readable and requirement focused interface and internals should be <a href="https://medium.com/swlh/the-importance-of-code-encapsulation-ce19efbcfe57">encapsulated</a></li>
</ul>
<h2>Test-Driven Development</h2>
<p>
	Test-Driven Development (acronym TDD) and is a workflow discipline for developers. TDD is focused on <i>when</i> to write unit tests. The workflow is not focused on <i>how</i> to write good unit test, so let's first go through that and then continue with the TDD definition.<br>
</p>
<figure>
	<img src="../assets/images/blog/tdd/what/tdd-red-green-refactor.svg" alt="TDD: RED GREEN REFACTOR" title="TDD: RED GREEN REFACTOR" class="imageSmallTextNoBorder">
	<figcaption>
		The three steps of the TDD cycle
	</figcaption>
</figure>
<ol class="list">
	<li><span class="redFail">RED:</span> Write a test and see it fail (verifying that the test is not passing when it should not)</li>
	<li><span class="greenPass">GREEN:</span> Get the test to pass with minimal effort</li>
	<li><span class="greenRefactor">REFACTOR:</span> Clean up <a href="https://pragmaticways.com/31-code-smells-you-must-know/">code smells</a> and improve the design (skip if not needed)</li>
</ol>
<p>
	The cycle should focus is on fulfilling a specific requirement on the SUT (Subject / Unit Under Test). The cycle should be repeated until you are confident that the SUT handles all required and meaningful cases (the more specific the tests become, the the more generic the SUT functionality becomes). All tests should be run at each step of the cycle.
</p>

<h2>Why do TDD ?</h2>
<p>Here is a my non-exhaustive list of the benefits of TDD in order of priority:</p>
<ol class="list inline">
	<li>Ensures you'll have passing test suite with high production code coverage<br>
		that runs fast (each case less than 0.1 sec) so you get feedback early,<br>
		thus you can clean the code fast and continuously without fear of breaking it,<br>
		thus have high confidence in the shipped product quality.<br></li>
	<li>It pushes for good production code design and maintainability:</li>
	<ul>
		<li><a href="https://effectivesoftwaredesign.com/2012/02/05/separation-of-concerns/">Separation of Concerns (SoC)</a></li>
		<li>code to be low <a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)">coupled</a> / have few dependencies</li>
		<li>each unit / object has readable and requirement-focused interface<br>
		(internals should be <a href="https://medium.com/swlh/the-importance-of-code-encapsulation-ce19efbcfe57">encapsulated</a>)</li>
	</ul>
	<li>The tests are accurate and up-to-date (developer focused) documentation<br>
		of the behavior of the tested units.</li>
	<li>Less time spent in the debugger</li>
</ol>
<p>
	There are also criticisms on TDD, e.g. the post <a href="https://dhh.dk/2014/tdd-is-dead-long-live-testing.html">TDD is dead. Long live testing</a>,<br>
	and discussion about it, e.g. the YouTube series <a href="https://www.youtube.com/watch?v=z9quxZsLcfo">Is TDD dead ?</a><br>
	and responses to it, e.g the post <a href="https://blog.cleancoder.com/uncle-bob/2014/04/25/MonogamousTDD.html">Monogamous TDD</a>.
</p>

<h2>Is TDD suitable for all areas / situations ?</h2>

<p>
	I have over a decade long <a href="https://www.linkedin.com/in/egillantonsson">developer work experience</a><br>
	mainly as front-end game developer, and shared game systems developer.<br>
	I've gained some experience in writing good unit tests (being 'not so good' at the start of the journey).<br>
	but I've used TDD to a lesser degree, thus I'm currently not very seasoned in using TDD.<br>
	The reason why I haven't used TDD more is mainly two-fold:
</p>
	<ul class="list inline">
		<li>Sometimes when facing many 'hard to influence' deadlines,<br>
			I've chosen the (not ideal) 'get it done in time' approach (Thus writing unit tests later).</li>
		<li>I'm working in areas / situations where it is not so suited or easy to use TDD.</li>
	</ul>
<p>
	Below are areas / situations where it is not so suited or easy to use TDD<br>
	(and some tips how to work TDD more into them).
</p>

<h3>Boundary layers</h3>
<p>
	A big part of a game is the graphic user interface (GUI) and visual effects, user input and sound,<br>
	should these parts be unit tested ?<br>
	<br>
	These parts can be described as layers close to the physical output/input boundaries (e.g. screen, speaker)<br>
	The design can be driven to make these boundary layers thin and <a href="http://xunitpatterns.com/Humble%20Object.html">humble</a>,<br>
	focusing on the responsibility of the boundary (e.g. disable/enable button), and extracting other logic into other modules that can be easily tested.<br>
	<br>
	It's likely that the logic to extract is in fact the <a href="https://enterprisecraftsmanship.com/posts/what-is-domain-logic/">domain logic</a> (a.k.a business logic),<br>
	the code that makes (non-visual) game decisions (business)<br>
	 and thus belongs to the <a href="https://enterprisecraftsmanship.com/posts/domain-model-isolation/">domain model</a> and then should be moved there<br>
	(the domain model should not depend on any boundaries, thus be easily unit testable).<br>
	<br>
	The edges of the boundary layers can be manually tested, e.g making sure the button displays properly on the screen.<br>
	If boundary bugs begin slipping into the production as the project grows,<br>
	then it's time to replace some of the manual testing effort with automated tests (e.g integration and/or UI tests).<br>
	The <a href="https://martinfowler.com/articles/practical-test-pyramid.html">Test Pyramid</a> could be a guide for that process.
</p>

<h3>Legacy Code</h3>
<p>
	Legacy code in a sentence is <a href="https://understandlegacycode.com/blog/what-is-legacy-code-is-it-code-without-tests/#code-youre-not-comfortable-changing">valuable code you are afraid to change</a><br>
	It typically:
</p>
<ul class="list inline">
	<li>has been developed for some time</li>
	<li>is already 'working' (for most common scenarios / most of the time)</li>
	<li>has some bad code design that has crept in with time<br>
		(e.g. high coupling / high dependency)</li>
	<li>is hard to read and understand and reason about</li>
	<li>has no or few good unit tests / very low test coverage<br>
		(or many very bad and fragile tests that are hard to read and understand</li>
</ul>
<p>
	When you need to fix or change legacy code<br>
	it is hard to do and have the confidence that the change did not break something else.<br>
	A breakage is discovered late (QA manual testing or live production) which can be very costly<br>
	(and it always takes effort to get again into the context to fix the bug).<br>
	<br>
	It's possible to prevent bad code design to creep up<br>
	by strictly upholding great design principles, without writing unit tests.<br>
	But using TDD complements this prevention very well (see <i>Why do TDD ?</i> section above)<br>
	<br>
	One of the negative consequence of legacy code is that it's very hard to write unit tests<br>
	They likely need a lot of <a href="http://xunitpatterns.com/Mocks,%20Fakes,%20Stubs%20and%20Dummies.html">Test Doubles</a> to mute dependency interference<br>
	(where static objects and <a href="https://medium.com/aia-sg-techblog/why-singleton-pattern-is-considered-as-anti-design-pattern-c81dd8b7e757">Singletons</a> become very tricky).<br>
	<br>
	Legacy code needs to be carefully refactored (ideally first covered with tests) into a better state<br>
	before TDD can be used effortlessly and to it's full potential.<br>
	Improving legacy code is a big topic thus I'll leave it here by<br>
	referencing one book: <a href="https://www.goodreads.com/book/show/44919.Working_Effectively_with_Legacy_Code">Working Effectively with Legacy Code</a>,<br>
	and one post: <a href="https://devon.global/starting-tdd-legacy-code/">Starting TDD with legacy code</a>.
</p>

<h3>Prototype code</h3>
<p>
	The focus of prototyping is to get out an idea as fast as possible to get feedback on it.<br>
	It should be time boxed and at the end of the period it should be decided if the idea should become a real production project or not,<br>
	and there should be a <b>clear agreement that the prototype code will be thrown away</b>.<br>
	It is fine to not (or sparsely) use TDD in the prototyping phase, if the consensus is it slows things down,<br>
	but TDD should be used when the production project codebase is started from scratch.<br>
</p>

<div class="horizontalLine"></div>

<h2>Comments</h2>

<h4>Fabio Paes Pedro</h4>

<p>
	I'm no expert but the value TDD provides became clear to me quite fast.<br>
	I believe this requires a mindset/process change though,<br>
	a different way of thinking things through that might extend outside of our team, into a company level.<br>
	I can't wait to read the rest of this series!
</p>
<h4>My response</h4>
<p>
	Thank you for your comment Fabio.<br>
	I agree that TDD requires a mindset/process change,<br>
	where ideally the whole team and the company are aligned on using TDD to reap its benefits,<br>
	(synced on an approach that recognizes that in some areas / situations the value of TDD can be limited (as the sections above go through).<br>
	I aim to continue writing blog post and complete this series, so stay tuned :)
</p>
<div class="horizontalLine"></div>

