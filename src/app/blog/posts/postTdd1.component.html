<!-- <h1>TDD-ing Avatar Health in C# via Unity</h1> -->
<h1>{{post.seriesTitle}}</h1>
<h2>{{post.title}}</h2>
<div class="byAndDate">
	<small>by Egill Antonsson<br>
		published on {{publishedDateToString}}<br>
	</small>
	<small *ngIf="hasUpdatedDate">
		updated on {{updatedDateToString}}
	</small>
</div>

<h2>What is TDD ?</h2>
<p>
	TDD is an acronym for <i>Test Driven Development</i><br>
	and is a workflow discipline / approach for developers, focused on <b>when</b> to write unit tests,<br>
	and the heart of it is the <a href="http://www.jamesshore.com/v2/blog/2005/red-green-refactor">RED / GREEN / REFACTOR cycle:</a>
</p>
<ol class="list">
	<li><span class="redFail">RED:</span> Write a test that fails</li>
	<li><span class="greenPass">GREEN:</span> Get the test to pass, with minimal effort</li>
	<li><span class="greenRefactor">REFACTOR:</span> if needed: generalize the solution, clean up the structure / design / <a href="https://pragmaticways.com/31-code-smells-you-must-know/">code smells</a> (all tests passing)</li>
</ol>
<p>The cycle should focus is on fulfilling a requirement on the SUT (Subject/Unit Under Test)<br>
	repeating it until you are confident that the production code has become generic enough to handle all input cases. (with test becoming more specific).<br>
	At some interval you should stop and evaluate if the design of the overall system is sound,<br>
	and refactor if needed (all test passing).<br>
	This is my summarization of Uncle Bob's post <a href="https://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html">The Cycles of TDD</a> and other sources.<br>
	(Bob terms additional cycles within and around RED / GREEN / REFACTOR in his post).
</p>

<h2>What is a good Unit Test ?</h2>
<p>
	A good unit test is focused on a specific SUT requirement,<br>
	of meaningful logic (e.g. don't test simple getter properties on their own).<br>
	The test code should be kept as clean as the production code (<span class="greenRefactor">REFACTOR</span> step in TDD applies to both).<br>
	Here are definitions from Roy Osherove in <i>The Art of Unit testing, 3rd edition</i><br>
	(for him the word 'unit' in unit testing stands for 'unit of work'):
</p>

<h3><a href="https://livebook.manning.com/book/the-art-of-unit-testing-third-edition/chapter-1/v-6/25">Unit of Work definition</a></h3>
<p>
A <i>unit of work</i> is the sum of actions that take place between the invocation of an <i>entry point</i><br>
up until a noticeable end result through one or more <i>exit points</i>.<br>
The <i>entry point</i> is the thing we trigger.<br>
Given a publicly visible function, for example:
</p>
<ul class="list inline">
	<li>The function's body is all or part of the <i>unit of work</i>.</li>
	<li>The function's declaration and signature are the <i>entry point</i> into the body.</li>
	<li>The resulting outputs or behaviors of the function are its <i>exit points</i>.</li>
</ul>

<h3><a href="https://livebook.manning.com/book/the-art-of-unit-testing-third-edition/chapter-1/v-6/193">Good Unit Test definition</a></h3>
<p>
A <i>unit test</i> is an automated piece of code that invokes the <i>unit of work</i><br>
through an <i>entry point</i>, and then checks one of its <i>exit points</i>.<br>
It can be written easily and runs quickly.<br>
<b>It's trustworthy, readable & maintainable.<br>
It is consistent as long as the production code we control has not changed.</b>
</p>

<h2>Why do TDD ?</h2>
<p>Here is a my non-exhaustive list of the benefits of TDD in order of priority:</p>
<ol class="list inline">
	<li>Ensures you'll have passing test suite with high production code coverage<br>
		that runs fast (each case less than 0.1 sec) so you get feedback early,<br>
		thus you can clean the code fast and continuously without fear of breaking it,<br>
		thus have high confidence in the shipped product quality.<br></li>
	<li>It pushes for good production code design and maintainability:</li>
	<ul>
		<li><a href="https://effectivesoftwaredesign.com/2012/02/05/separation-of-concerns/">Separation of Concerns (SoC)</a></li>
		<li>code to be low <a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)">coupled</a> / have few dependencies</li>
		<li>each unit / object has readable and requirement-focused interface<br>
		(internals should be <a href="https://medium.com/swlh/the-importance-of-code-encapsulation-ce19efbcfe57">encapsulated</a>)</li>
	</ul>
	<li>The tests are accurate and up-to-date (developer focused) documentation<br>
		of the behavior of the tested units.</li>
	<li>Less time spent in the debugger</li>
</ol>
<p>
	There are also criticisms on TDD, e.g. the post <a href="https://dhh.dk/2014/tdd-is-dead-long-live-testing.html">TDD is dead. Long live testing</a>,<br>
	and discussion about it, e.g. the YouTube series <a href="https://www.youtube.com/watch?v=z9quxZsLcfo">Is TDD dead ?</a><br>
	and responses to it, e.g the post <a href="https://blog.cleancoder.com/uncle-bob/2014/04/25/MonogamousTDD.html">Monogamous TDD</a>.
</p>

<h2>Is TDD suitable for all areas / situations ?</h2>

<p>
	I have over a decade long <a href="https://www.linkedin.com/in/egillantonsson">developer work experience</a><br>
	mainly as front-end game developer, and shared game systems developer.<br>
	I've gained some experience in writing good unit tests (being 'not so good' at the start of the journey).<br>
	but I've used TDD to a lesser degree, thus I'm currently not very seasoned in using TDD.<br>
	The reason why I haven't used TDD more is mainly two-fold:
</p>
	<ul class="list inline">
		<li>Sometimes when facing many 'hard to influence' deadlines,<br>
			I've chosen the (not ideal) 'get it done in time' approach (Thus writing unit tests later).</li>
		<li>I'm working in areas / situations where it is not so suited or easy to use TDD.</li>
	</ul>
<p>
	Below are areas / situations where it is not so suited or easy to use TDD<br>
	(and some tips how to work TDD more into them).
</p>

<h3>Boundary layers</h3>
<p>
	A big part of a game is the graphic user interface (GUI) and visual effects, user input and sound,<br>
	should these parts be unit tested ?<br>
	<br>
	These parts can be described as layers close to the physical output/input boundaries (e.g. screen, speaker)<br>
	The design can be driven to make these boundary layers thin and <a href="http://xunitpatterns.com/Humble%20Object.html">humble</a>,<br>
	focusing on the responsibility of the boundary (e.g. disable/enable button), and extracting other logic into other modules that can be easily tested.<br>
	<br>
	It's likely that the logic to extract is in fact the <a href="https://enterprisecraftsmanship.com/posts/what-is-domain-logic/">domain logic</a> (a.k.a business logic),<br>
	the code that makes (non-visual) game decisions (business)<br>
	 and thus belongs to the <a href="https://enterprisecraftsmanship.com/posts/domain-model-isolation/">domain model</a> and then should be moved there<br>
	(the domain model should not depend on any boundaries, thus be easily unit testable).<br>
	<br>
	The edges of the boundary layers can be manually tested, e.g making sure the button displays properly on the screen.<br>
	If boundary bugs begin slipping into the production as the project grows,<br>
	then it's time to replace some of the manual testing effort with automated tests (e.g integration and/or UI tests).<br>
	The <a href="https://martinfowler.com/articles/practical-test-pyramid.html">Test Pyramid</a> could be a guide for that process.
</p>

<h3>Legacy Code</h3>
<p>
	Legacy code in a sentence is <a href="https://understandlegacycode.com/blog/what-is-legacy-code-is-it-code-without-tests/#code-youre-not-comfortable-changing">valuable code you are afraid to change</a><br>
	It typically:
</p>
<ul class="list inline">
	<li>has been developed for some time</li>
	<li>is already 'working' (for most common scenarios / most of the time)</li>
	<li>has some bad code design that has crept in with time<br>
		(e.g. high coupling / high dependency)</li>
	<li>is hard to read and understand and reason about</li>
	<li>has no or few good unit tests / very low test coverage<br>
		(or many very bad and fragile tests that are hard to read and understand</li>
</ul>
<p>
	When you need to fix or change legacy code<br>
	it is hard to do and have the confidence that the change did not break something else.<br>
	A breakage is discovered late (QA manual testing or live production) which can be very costly<br>
	(and it always takes effort to get again into the context to fix the bug).<br>
	<br>
	It's possible to prevent bad code design to creep up<br>
	by strictly upholding great design principles, without writing unit tests.<br>
	But using TDD complements this prevention very well (see <i>Why do TDD ?</i> section above)<br>
	<br>
	One of the negative consequence of legacy code is that it's very hard to write unit tests<br>
	They likely need a lot of <a href="http://xunitpatterns.com/Mocks,%20Fakes,%20Stubs%20and%20Dummies.html">Test Doubles</a> to mute dependency interference<br>
	(where static objects and <a href="https://medium.com/aia-sg-techblog/why-singleton-pattern-is-considered-as-anti-design-pattern-c81dd8b7e757">Singletons</a> become very tricky).<br>
	<br>
	Legacy code needs to be carefully refactored (ideally first covered with tests) into a better state<br>
	before TDD can be used effortlessly and to it's full potential.<br>
	Improving legacy code is a big topic thus I'll leave it here by<br>
	referencing one book: <a href="https://www.goodreads.com/book/show/44919.Working_Effectively_with_Legacy_Code">Working Effectively with Legacy Code</a>,<br>
	and one post: <a href="https://devon.global/starting-tdd-legacy-code/">Starting TDD with legacy code</a>.
</p>

<h3>Prototype code</h3>
<p>
	The focus of prototyping is to get out an idea as fast as possible to get feedback on it.<br>
	It should be time boxed and at the end of the period it should be decided if the idea should become a real production project or not,<br>
	and there should be a <b>clear agreement that the prototype code will be thrown away</b>.<br>
	It is fine to not (or sparsely) use TDD in the prototyping phase, if the consensus is it slows things down,<br>
	but TDD should be used when the production project codebase is started from scratch.<br>
</p>

<div class="horizontalLine"></div>

<h2>Comments</h2>

<h4>Fabio Paes Pedro</h4>

<p>
	I'm no expert but the value TDD provides became clear to me quite fast.<br>
	I believe this requires a mindset/process change though,<br>
	a different way of thinking things through that might extend outside of our team, into a company level.<br>
	I can't wait to read the rest of this series!
</p>
<h4>My response</h4>
<p>
	Thank you for your comment Fabio.<br>
	I agree that TDD requires a mindset/process change,<br>
	where ideally the whole team and the company are aligned on using TDD to reap its benefits,<br>
	(synced on an approach that recognizes that in some areas / situations the value of TDD can be limited (as the sections above go through).<br>
	I aim to continue writing blog post and complete this series, so stay tuned :)
</p>
<div class="horizontalLine"></div>

