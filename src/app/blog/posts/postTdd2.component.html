<h1>{{post.seriesTitle}}</h1>
<h2>{{post.title}}</h2>
<div class="byAndDate">
	<small>by Egill Antonsson<br>
		published on {{publishedDateToString}}<br>
	</small>
	<small *ngIf="hasUpdatedDate">
		updated on {{updatedDateToString}}
	</small>
</div>

<h2>Preparing the assignment</h2>
<h3>My workshop</h3>
<p>
	I recently to do a short workshop about TDD at <a href="https://www.maginteractive.com">work</a><br>
	and for preparation I browsed the internet looking for a fitting assignment,<br>
	and I came across <a href="https://www.youtube.com/watch?v=R1aO4Tmw3zA&list=PLKERDLXpXl_jJQiQOHDLimnulasAK3T5b">TDD in Unity - Part 1</a> by Charles Amat, where he sets up his assignment:<br>
	implementing the <i>Life Gauge</i> from <i>Zelda: Breath of the Wild</i> game.<br>
	<br>
	I thought this assignment was fitting for the workshop,<br>
	 thus I read the <a href='https://zelda.fandom.com/wiki/Life_Gauge'>Life Gauge page on the Zelda wiki</a> (which was linked in the 'Part 1' post),<br>
	and also played the game a bit, focusing on the <i>Life Gauge</i> behavior.<br>
	But I did not go through the 'TDD in Unity' series, as I was running out of preparation time.<br>
	<br>
	My focus and task order in both my preparations and workshop walk-through:<br>
</p>
<ol class="list inline">
	<li>Write down the <i>Life Gauge</i> behavior from the user perspective<br>
		(based on the wiki, and to a lesser degree my experience, as I'm not so good in <i>Zelda: Breath of the Wild</i>)</li>
		<br>
	<li>Focus first on the (non visual) domain logic and implement all the requirements it should fulfill,<br>
		as TDD is fully effective and effortless in the domain model</li>
		<br>
	<li>Afterwards the focus would shift to the visual GUI,<br>
		where the value of TDD likely would dwindle the closer I got to the physical boundary of the screen,<br>
		ending with just manually testing with my eyes.<br>
		(Boundary layers section in <a href="https://egill.rocks/blog/tdd-health/part1">Part 1</a> elaborates on 2. and 3.)</li>
</ol>
<p>
	I only had time prepare the first couple of domain logic requirements,<br>
	and during the workshop we collaboratively completed those together<br>
	(before the time was up).<br>
</p>

<h3>Comparing approaches on the assignment</h3>
<p>
	After the workshop I was curious how Charles Amat solved it,<br>
	thus I watched on YouTube the whole <a href="https://www.youtube.com/watch?v=R1aO4Tmw3zA&list=PLKERDLXpXl_jJQiQOHDLimnulasAK3T5b">TDD in Unity</a> series.<br>
	I both enjoyed and learned from watching Charles Amat <a href="https://en.wikipedia.org/wiki/Live_coding">live coding</a> and implementing the <i>Life Gauge</i><br>
	and his end result solution is good and sound, and I thank Charles for his contribution.<br>
	but I noticed that his focus and task order quite differed from mine, as he:<br>
</p>
<ol class="list inline">
	<li>Starts planning how to create the heart container in Unity,<br>
		from a GUI perspective</li>
	<br>
	<li>Starts TDD-ing logic close to the GUI</li>
	<br>
	<li>Ends with TDD-ing the domain logic (<a href="https://www.youtube.com/watch?v=_vd2JyX6C1Y&list=PLKERDLXpXl_jJQiQOHDLimnulasAK3T5b&index=8">Part 7</a> and <a href="https://www.youtube.com/watch?v=LPlH87XaWC8&list=PLKERDLXpXl_jJQiQOHDLimnulasAK3T5b&index=9">Part 8</a>).<br>
		He simplifies the domain requirements from the <i>Breath of the Wild</i><br>
		as he states in the beginning<br>
		<q>The Heart container depletes when the player takes damage<br>
			and is replenished when the player consumes an item with a health effect.
		</q>
	</li>
</ol>

<h3>Same assignment, but with a different focus</h3>
<p>
	This is why I think it's worth doing another series with the same assignment,<br>
	but with my focus, task order, and format.<br>
	<br>
	My format will be blog posts focused on the TDD cycles<br>
	displaying the appropriate code for each step.<br>
	I'll demonstrate how the requirements and the cycles<br>
	guide and shape the code and my reasoning,<br>
	that will read like poetry of rhythmic <span class="redFail">RED </span><span class="greenPass">GREEN </span> <span class="greenRefactor">REFACTOR </span> loops,<br>
	at least that's my ambition :)<br>
</p>

<h2>The Life Gauge behavior</h2>
<p>
	The below list is user perspective behaviour summary from<br>
	the <a href='https://zelda.fandom.com/wiki/Life_Gauge'>Life Gauge page on the Zelda Wiki</a> for the <i>Breath of the Wild</i> game<br>
	(Small streamlining done for the sake of the assignment):

</p>
<ul class="list">
	<li class="noBulletinPoint"><b>Definition and Start State</b></li>
	<li>The Life Gauge measures Link's (the avatar) current amount of health</li>
	<li>Health is visually represented in the form of Hearts, and they are in fractions of 4</li>
	<li>The Life Gauge starts with 3 Hearts</li>
	<br>
	<li class="noBulletinPoint"><b>Taking Damage and Dying</b></li>
	<li>Whenever Link takes damage he will lose a certain amount of Heart fractions<br>
		equal to the damage points taken (always losing at least 1 fraction)</li>
	<li>When Link loses all of his Hearts the game ends</li>
	<li>Link is protected from any damage that would instantly kill him as long as his Life Gauge is full<br>
		and will instead be left alive with Hearth 1 fraction remaining</li>
	<ul>
		<li>However, if the damage is more than five Hearts above his full Life Gauge, he will still die</li>
	</ul>
	<br>
	<li class="noBulletinPoint"><b>Replenishing and Maximum</b></li>
	<li>Link's Life Gauge can be replenished by:<br>
		<ul>
			<li>Picking up recovery Hearts / drinking recovery Potions</li>
			<li>Resting while Sitting or Sleeping.</li>
		</ul>
	<li>The Life Gauge can be extended to a maximum of 30 Hearts</li>
	<li>It can also be temporarily extended by consuming certain Foods that grant yellow temporary Hearts</li>
		<ul>
			<li>These yellow Hearts are lost when Link takes damage and cannot be recovered</li>
		</ul>
</ul>

<h3>Domain / Visual <i>SoC</i> mapping of <i>Life Gauge</i></h3>
<table>
	<tr>
		<th>Domain Model</th>
		<th>GUI / View</th>
	</tr>
	<tr>
		<td class="center">
			Avatar Health
		</td>
		<td class="center">
			Heart Container
		</td>
	</tr>
	<tr>
		<td class="center">
				-
		</td>
		<td class="center">
			Heart (contains 4 Fractions)
		</td>
	</tr>
	<tr>
		<td class="center">
			Health Points
		</td>
		<td class="center">
			Heart Fraction
		</td>
	</tr>
</table>
<p>
	This <i>Separation of Concerns (SoC)</i> mapping is good to establish early:<br>
	Heart Container (with its Hearts and fractions)<br>
		is a specific GUI representation of the Avatar Health, the domain model.<br>
	<br>
	I'll apply the approach noted in the <i>Boundary layers</i> section in <a href="./blog/tdd-health/part1">Part 1</a>,<br>
	Making sure that the code dependency is minimal and one-way:<br>
	The view can depend in some way on the model, but not vice-versa.<br>
	All the domain logic should be in the model<br>
	and the view should be thin and humble.<br>
	<br>
	When future change requests on the GUI arrive<br>
	(which is quite likely, in a real-life scenario),<br>
	it will be effortless to handle as:
</p>
<ul class="list inline">
	<li>The domain and its logic will be unaffected<br>
		(as it does not depend on the view)</li>
	<li>The model naming and terms will be unaffected<br>
		(as it does not depend on the view)</li>
</ul>
<p>
	This also makes it effortless to have simultaneously more than one<br>
	GUI representations of the same model (quite common in game UI).
</p>
