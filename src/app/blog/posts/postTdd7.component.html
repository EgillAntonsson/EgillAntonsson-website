<h1>{{post.seriesTitle}}</h1>
<h2>{{post.title}}</h2>
<div class="byAndDate">
	<small>by Egill Antonsson<br>
		published on {{publishedDateToString}}<br>
	</small>
	<small *ngIf="hasUpdatedDate">
		updated on {{updatedDateToString}}
	</small>
</div>

<h2>The extending to maximum requirements</h2>
<p>
	Let's recap the next requirement from the user perspective:
</p>

<ul class="list">
	<li>The Life Gauge can be extended to a maximum of 30 Hearts</li>
</ul>
<div [innerHTML]="completeRequirementListHtml"></div>

<p>
	{{rewordRequirement}}
</p>
<ul class="list">
	<li><code>FullPoints</code> can be permanently increased from 4 <code>HealthPoints</code> up to a maximum of 120 <code>HealthPoints</code><br></li>
</ul>

<p>
	For this requirement it makes sense to define a new unit in <code>Health</code><br>
	that equals to 4 Health Points<br>
	(that visually is represented as a Heart (or something else)),<br>
	as the increase should always be in that unit.<br>
</p>
<h3>Domain / Visual SoC mapping, revisited</h3>
<table>
	<tr>
		<th>Domain Model</th>
		<th>GUI / View</th>
	</tr>
	<tr>
		<td class="center">
			(Avatar) Health
		</td>
		<td class="center">
			Life Gauge
		</td>
	</tr>
	<tr>
		<td class="center">
			<b><i>Unit Container</i></b>
		</td>
		<td class="center">
			Heart Container
		</td>
	</tr>
	<tr>
		<td class="center">
				<b><i>Unit</i></b>
		</td>
		<td class="center">
			Heart (equals 4 Fractions)
		</td>
	</tr>
	<tr>
		<td class="center">
			Points
		</td>
		<td class="center">
			Heart Fraction
		</td>
	</tr>
</table>
<p>
	I add nem domain definitions <i>Unit Container</i> and <i>Unit</i> to the mapping.<br>
	now let's reword the requirement with this new definition:<br>
</p>
<ul class="list">
	<li><code>FullPoints</code> can be permanently increased by 1 <i>Unit Container</i> up to a maximum of 30 <i>Unit Containers</i></li>
	<ul>
		<li>the <code>CurrentPoints</code> are also increased by the same <i>Unit</i> amount</li>
	</ul>
</ul>

<div [innerHTML]="aboutCodeHtml"></div>

<h2>Entry point<code>IncreaseByUnit</code></h2>

<p>
	The domain model focus will be a new method named <code>IncreaseByUnit</code>.<br>
</p>

<h2>Exit point <code>FullPoints</code></h2>
<h3><span class="redFail">RED</span></h3>
<p>
	I write a test for the existing <i>exit point</i> <code> FullPoints</code> property.
</p>
<pre><code [highlight]="red_fullPointsIncrease"></code></pre>

<h3><span class="greenPass">GREEN</span></h3>
<p>
	I make the test pass with an effortless implementation.
</p>
<pre><code [highlight]="green_fullPointsIncrease"></code></pre>
<p>
	I don't like the 'magic' number <code>4</code> and thus I'll refactor it.
</p>

<h3><span class="greenRefactor">REFACTOR</span></h3>

<pre><code [highlight]="refactor_fullPointsIncrease"></code></pre>

<p>
	I replaced the 'magic' number with a constant member<br>
	and gave it a meaningful name that explains the number.<br>
	I set the access modifier of the constant to <code>public</code>,<br>
	as it provides value to the users of the system to know about and potentially use.<br>
	<br>
	I feel confident that I have the generic solution, but let's add test cases with different inputs to verify
</p>

<h3><span class="greenRefactor">REFACTOR (add test cases)</span></h3>

<pre><code [highlight]="refactor_fullPointsIncrease_addTests"></code></pre>
<p>
	I replaced the previous test with this one.<br>
	When selecting the values for the test cases, it crossed my mind that sending 0 for param unit would be a big 'nono',
	so let's cycle the invalid <input type="button" value="">.
</p>

<h2>Handle invalid input</h2>

<h3><span class="redFail">RED</span></h3>
<p>
	I copy / paste ThrowsError_WhenReplenishPointsIsInvalid and update accordingly
</p>
<pre><code [highlight]="red_fullPointsIncrease_invalidInput"></code></pre>

<h3><span class="greenPass">GREEN</span></h3>
<p>
	I make the test pass with an effortless implementation, reusing ValidatePoints method.
</p>
<pre><code [highlight]="green_fullPointsIncrease_invalidInput"></code></pre>

<h2>Exit point <code>CurrentPoints</code></h2>
<p>
	This requirement also states that <code>CurrentPoints</code> should increase by the same <code>Unit</code> amount.<br>
	This should be another test case as <code>CurrentPoints</code> is a different <i>exit point</i><br>
	(see Good Unit Test definition in <a href="./blog/tdd-health/part1">part 1</a>), so we cycle it.
</p>

<h3><span class="redFail">RED</span></h3>

<pre><code [highlight]="red_fullPointsIncrease_currentPoints"></code></pre>

<p>Let's make it pass</p>

<h3><span class="greenPass">GREEN</span></h3>

<pre><code [highlight]="green_fullPointsIncrease_currentPoints"></code></pre>
<p>
	I effortlessly added the last line to the method, and then the test passes.<br>
	I think this will not hold for other cases, so lets to another cycle to drive it.
</p>

<h3><span class="redFail">RED</span></h3>

<pre><code [highlight]="red_fullPointsIncrease_currentPoints_moreCases"></code></pre>

<h3><span class="greenPass">GREEN</span></h3>

<pre><code [highlight]="green_fullPointsIncrease_currentPoints_moreCases"></code></pre>
<p>
	Now all the tests pass. I see I can refactor the points increase multiplication to be done just once.
</p>

<h3><span class="greenRefactor">REFACTOR</span></h3>

<pre><code [highlight]="refactor_fullPointsIncrease_currentPoints_moreCases"></code></pre>

<p>
	Now the last part of the requirement is that <code>FullPoints</code> can increase to a maximum of 30 Units.
</p>

<h2>Maximum increase</h2>

<h3><span class="redFail">RED</span></h3>

<pre><code [highlight]="red_fullPointsIncrease_currentPoints_moreCases"></code></pre>
