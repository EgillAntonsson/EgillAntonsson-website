<h1>{{post.seriesTitle}}</h1>
<h2>{{post.title}}</h2>
<div class="byAndDate">
	<small>by Egill Antonsson<br>
		published on {{publishedDateToString}}<br>
	</small>
	<small *ngIf="hasUpdatedDate">
		updated on {{updatedDateToString}}
	</small>
</div>

<h2>The requirement</h2>
<p>
	Let's recap this requirements from the user perspective:
</p>

<ul class="list inline">
	<li>The Life Gauge can be increased by 1 Heart at a time</li>
	<ul>
		<li>Link's health will become full with the increase</li>
	</ul>
	<li>The maximum of Hearts is 30</li>
</ul>
<p>
Increasing the Health is a significant gameplay event In <i>Breath of the Wild</i><br>
(solving puzzles in shrines to get Spirit Orbs, then find and pray to a Goddess Statue),<br>
and thus the increase is always 1 Heart each time, no more or less.
</p>
<div [innerHTML]="completeRequirementListHtml"></div>

<p>
	Now it makes sense to define a new unit in <code>Health</code> that equals 4 <code>Points,</code><br>
that is visually represented as a Heart (or something else),<br>
	as the increase should always be in that unit.<br>
</p>
<h2>Domain / View mapping (revisited)</h2>
<p>
	I add a new domain definition <i>Unit</i> that maps to the visualized <i>Heart</i>
</p>
<table>
	<tr>
		<th><b>Domain Model</b></th>
		<th><b>View / GUI</b></th>
	</tr>
	<tr>
		<td class="center">
			(Avatar) Health
		</td>
		<td class="center">
			Life Gauge
		</td>
	</tr>
	<tr>
		<td class="center">
				<b><i>Unit</i></b>
		</td>
		<td class="center">
			Heart (holds 4 Fractions)
		</td>
	</tr>
	<tr>
		<td class="center">
			Points
		</td>
		<td class="center">
			Heart Fractions
		</td>
	</tr>
</table>

<p>
With <i>Unit</i> defined, I realize that it's beneficial to redefine some 'points' variables into 'unit':<br>
</p>
<ul class="list inline">
	<li><code>startingPoints</code> -> <code>startingUnits</code></li>
	<ul>
		<li>This fits the <code>Units</code> constraint in <i>Breath of the Wild</i> (starts with 3 <code>Units</code>)<br>
		<li>Also in general this is very reasonable constraint game-balancing wise, and simplifies the logic</li>
		<li>Note that <code>FullPoints</code> make sense to stay as points but will always equivalent to a whole Unit/s, due to its requirements (via 'starting' and 'increasing'</li>
	</ul>
	<li><code>MaxNegativePointsForInstantKillProtection</code> -> <code>MaxNegativeUnitsForInstantKillProtection</code></li>
	<ul>
		<li>This fits the <code>Units</code> constraint in <i>Breath of the Wild</i> (is 5 <code>Units</code>)<br>
		<li>Also in general this is very reasonable constraint game-balancing wise, and simplifies the logic</li>
	</ul>
</ul>

<p>
Now let's reword the requirements focusing on the domain model and using its updated terminology:
</p>
<ul class="list inline">
	<li><code>FullPoints</code>can be increased by 1 <code>Unit</code> at a time</li>
	<ul>
		<li><code>CurrentPoints</code> get same value as <code>FullPoints</code></li>
	</ul>
	<li><code>MaxUnits</code> (hereby named) is 30</li>
</ul>

<div [innerHTML]="aboutCodeHtml"></div>

<h2>Refactoring</h2>

<h3><span class="greenRefactor">REFACTOR to <code>startingUnits</code></span></h3>
<p>
In <code>HealthTest</code> I rename <code>startingPoint</code> to <code>startingUnits</code>.<br>
I update the values accordingly by defining and using a new constant <code>PointsPerUnits</code> in <code>Health</code>.<br>
I rename the parameter in <code>Health</code> class.<br>
I rename and update the values for <code>MaxNegativeUnitsForInstantKillProtection</code>.<br>
I'll only show the main changes in <code>Health</code> for this step.
</p>
<pre><code [highlight]="refactor_health"></code></pre>

<h2>Entry point <code>IncreaseByUnit</code></h2>
<p>
	The domain model focus will be a new method named <code>IncreaseByUnit</code>.<br>
</p>

<h2>Exit point <code>FullPoints</code></h2>
<p>
	Focusing first on the existing <code>FullPoints</code> property.
</p>
<h3><span class="redFail">RED</span></h3>

<pre><code [highlight]="red_increaseByUnit_fullPointsIncrease"></code></pre>

<h3><span class="greenPass">GREEN</span></h3>
<p>
	I make the test pass with an effortless implementation.
</p>
<pre><code [highlight]="green_increaseByUnit_fullPointsIncrease"></code></pre>
<p>
	I don't like that the 'magic' number <code>4</code> does not explain<br>
	the relationship between <code>Points</code> and <code>Unit</code>.<br>
	Thus I refactor it.
</p>

<h3><span class="greenRefactor">REFACTOR</span></h3>

<pre><code [highlight]="refactor_increaseByUnit_fullPointsIncrease"></code></pre>
<p>
	Now it's replaced with a meaningfully named constant member<br>
	that defines and documents well this relationship (in the code itself).<br>
</p>

<h2>Exit point <code>CurrentPoints</code></h2>
<p>
	Now I focus on the other <i>exit point</i>, the existing <code>CurrentPoints</code> property.<br>
	It should have new tests as it's about a different <i>exit point</i><br>
	(see Good Unit Test definition in <a href="./blog/tdd-health/part1">part 1</a>).
</p>

<h3><span class="redFail">RED</span></h3>

<pre><code [highlight]="red_increaseByUnit_currentPointsIncrease"></code></pre>

<h3><span class="greenPass">GREEN</span></h3>

<pre><code [highlight]="green_increaseByUnit_currentPointsIncrease"></code></pre>
<p>
	I effortlessly add the line <code>CurrentPoints = FullPoints</code>,<br>
	which is enough to make the test pass,<br>
	but I know that it only holds for this particular case, and not for others.<br>
	Thus I'll cycle the other cases.
</p>

<h3><span class="redFail">RED</span></h3>
<pre><code [highlight]="red_increaseByUnit_currentPoints_moreCases"></code></pre>
<p>
	I select <code>4</code> for the <code>startingPoints</code> parameter value<br>
	so all possible test cases will be the minimum <code>3</code>,<br>
	and other parameter values will be low as well,<br>
	which makes the test simple and readable.
</p>

<h3><span class="greenPass">GREEN</span></h3>

<pre><code [highlight]="green_increaseByUnit_currentPoints_moreCases"></code></pre>
<p>
	I could have taken a bigger step in the previous <span class="greenPass">GREEN</span> step<br>
	and come straight away with this generic solution,<br>
	but both paths should lead to the same result (both solution and tests),<br>
	the path presented here make the tests drive the implementation a bit more.
</p>

<h2>The maximum</h2>
<p>
	All that is left of the requirement is the maximum part.<br>
	The game will only give the user the option to spend resources<br>
	to increase the health if the <code>MaxUnits</code> has not been reached.
	Thus the outside code should query <code>Health</code> if maximum has been reached<br>
	and then only invoke <code>IncreaseByUnit</code> if not.<br>
	<code>IncreaseByUnit</code> should though also handle improper usage in this regard.
</p>

<h3><span class="redFail">RED</span></h3>
<p>
	The <i>entry point</i> will be a new property named <code>IsMaxUnitsReached</code>.<br>
</p>

<pre><code [highlight]="red_IsMaxUnitsReached"></code></pre>
<p>
	I'm presenting a bigger step, adding 2 test at the same time,<br>
	(thus skipping the smaller cycles I did within it).<br>
	<br>
	Here I can concise the test names<br>
	as the <i>exit point</i> is the same as the <i>entry point</i>,<br>
	thus I skip the <i>exit point</i> in the name (nested class already names it).<br>
	<br>
	The tests use a new constant <code>MaxUnits</code>,<br>
	and there are two compile errors as both<br>
	<code>MaxFullPoints</code> and <code>IsMaxUnitsReached</code> are not defined.
</p>

<h3><span class="greenPass">GREEN</span></h3>
<pre><code [highlight]="green_IsMaxUnitsReached"></code></pre>
<p>
	I define the constant and give it the proper value.<br>
	And I implement the read-only property as an <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members">Expression-Bodied Member</a>.<br>
</p>

<h2>Handle improper usage of <code>IncreaseByUnit</code></h2>
<p>
	If the outside code incorrectly invokes <code>IncreaseByUnit</code> when <code>IsMaxFullPointsReached</code> is <code>true</code>,<br>
	the method should handle it.
</p>
<h3><span class="redFail">RED</span></h3>
<pre><code [highlight]="red_IncreaseByUnit_ThrowsError"></code></pre>
<p>
	I deem I can use existing <code>InvalidOperationException</code> from <code>System</code>, if I include an informative message for my case.<br>
	<br>
	I assert that the message contains string <i>invalid</i>.<br>
	I'm intentionally not being more specific to minimize the assert will fail later if the message is reworded.<br>
	This simple <i>Resistance to refactoring</i> makes it a less fragile unit test.<br>
	(The book <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members">Unit Testing Principles, Practices, and Patterns</a> by Vladimir Khorikov, lists<i>Resistance to refactoring</i> os one of the 4 pillars of good unit test).
</p>

<h3><span class="greenPass">GREEN</span></h3>
<pre><code [highlight]="green_IncreaseByUnit_ThrowsError"></code></pre>
<p>
	I pass the test by adding the <i>if</i> condition at the start of the method.<br>
	<br>
	Now the requirement has been fulfilled and the Unity Test Runner looks like this:
</p>
<figure>
	<img src="../assets/images/blog/tdd/TestRunner_after-increase-tests.PNG" alt="Unity Test Runner: after adding Increase tests" title="Unity Test Runner: after adding Increase tests" class="imageSmallText">
	<figcaption>
		Unity Test Runner: after adding Increase tests
	</figcaption>
</figure>
