<h1>{{post.seriesTitle}}</h1>
<h2>{{post.title}}</h2>
<div class="byAndDate">
	<small>by Egill Antonsson<br>
		published on {{publishedDateToString}}<br>
	</small>
	<small *ngIf="hasUpdatedDate">
		updated on {{updatedDateToString}}
	</small>
</div>
<h2>Setting up Unity</h2>
<p>
	I'm using Unity version 2020.3.24f1 and I create a new project (3D is the default), and keep the default config,<br>
	except that I update <i>Test Framework</i> package to latest version (currently 1.1.30).<br>
	The <a href="https://docs.unity3d.com/Packages/com.unity.test-framework@1.1/manual/index.html">documentation</a> details how setup tests for a project.<br>
	My project structure starts very simple:
</p>
<ul class="list inline">
	<li>The test code is in: <i>Scripts/Tests/EditMode/[ClassName]Test.cs</i></li>
	<li>The production code is in: <i>Scripts/Runtime/[ClassName].cs</i></li>
</ul>
<p>
	As the folder structure implies, I'm doing <i>EditMode</i> tests for the production <i>Runtime</i> code.<br>
	<i>EditMode</i> test have access to both:
	<ul class="list inline">
		<li>the <i>Editor</i> code (only about extending the Unity editor)</li>
		<li>the <i>Runtime</i> code (of the targeted platform, e.g iOS).</li>
	</ul>
<p>
	My main reason to prefer <i>EditMode</i> tests for <i>Runtime</i> code<br>
	is that they run faster (as no startup of the Player is needed in the Unity editor).<br>
	Also the domain logic should not need the <i>PlayMode</i> tests features<br> (tests can run as Unity <i>Coroutine</i> to step through the (coroutine based) production code).<br>
	The doc page <a href="https://docs.unity3d.com/Packages/com.unity.test-framework@1.1/manual/edit-mode-vs-play-mode-tests.html">EditMode vs. PlayMode tests</a> explains their difference further.

<h2>The requirements for <i>definition and start state</i></h2>
<p>
	Let's recap these requirements from the user perspective:
</p>
<ul class="list inline">
	<li>The Life Gauge measures Link's (the avatar) current amount of health</li>
	<li>Health is visually represented in the form of Hearts, and they are in fractions of 4</li>
	<li>The Life Gauge starts with 3 Hearts</li>
</ul>
<p>
	Let's filter and transform this into a requirement that's focused only on the domain<br>
	(as GUI will be done later):
</p>
<ul class="list inline">
	<li>Avatar Health starts with 12 Health Points<br>
		(equals to visual representation of 3 Hearts * 4 Fractions)</li>
</ul>

<h2>Health Points starting value</h2>

<h3><span class="redFail">RED (does not compile)</span></h3>
<p>
	I start by writing the test.<br>
	The domain model focus will be <code>Health</code> class (not created yet),<br>
	<span class="outOfScope">which in the end will likely be owned by <code>Avatar</code> class.</span><br>
	Thus I create test file <code>HealthTest.cs</code> and write the first test,<br>
	that fails as the code does not compile.
</p>
<pre><code [highlight]="test_1_Red"></code></pre>
<p>
	I'm using a naming/structuring convention by using nested test classes.<br>
	I name the nested class after the <i>entry point</i> of the test,<br>
	which in this case is the constructor method<br>
	(see <i>What is a good Unit Test section</i> in <a href="./blog/tdd-health/part1">Part 1</a>).<br>
	that I discovered this convention via Charles Amat via <a href="http://infalliblecode.com/unity-tdd-1/">TDD in Unity - Part 1</a><br>
	that references Erik Dietrich via <a href="https://daedtech.com/tdd-and-modeling-a-chess-game/">TDD and modeling a chess game</a><br>
	that references Phil Haack via <a href="https://haacked.com/archive/2012/01/02/structuring-unit-tests.aspx/">Structuring Unit Tests</a><br>
	<br>
	I'm using the <a href="https://docs.nunit.org/articles/nunit/writing-tests/assertions/assertions.html#two-models">Constraint Model of Assertions</a>.
</p>

<h3><span class="redFail">RED (test fails)</span></h3>
<p>
	I want to run the test and see it fail.<br>
	This is done to verify that the test is not passing when it should not<br>
	(provides more value for more complex scenario).<br>
	Thus I write the needed production code for the compiler to compile successfully,<br>
	then run the tests via Unity Test Runner (menu item <i>Window > General > Test Runner</i>).<br>
</p>
<pre><code [highlight]="test_1_Red2"></code></pre>
<figure>
	<img src="../assets/images/blog/tdd/TestRunner_first-test-fails.PNG" alt="Unity Test Runner: first test fail (the nested class displays nicely)" title="Unity Test Runner: first test fail (the nested class displays nicely)" class="imageSmallText">
	<figcaption>
		Unity Test Runner: first test fail (the nested class displays nicely)
	</figcaption>
</figure>
<p>
	Going forward I will skip demonstrating the step from 'does not compile' to 'test fails'<br>
	(although I actually do it when coding),<br>
	thus having only one <span class="redFail">RED</span> step.
</p>

<h3><span class="greenPass">GREEN</span></h3>
<p>Let's make the test pass with a very simple implementation.
</p>
<pre><code [highlight]="impl_1_Green"></code></pre>

<h3><span class="greenRefactor">REFACTOR</span></h3>

<p>Now it comes to mind that from a game design perspective<br>
	it's good to be able to tweak the starting points for game balancing,<br>
	thus I refactor the value to be passed as parameter into the constructor.<br>
	<span class="outOfScope">An advanced system would have an accessible<br>
		game balancing config that the code would read the values<br>
		and then pass them into the <span class="code">Health</span> constructor.</span><br>
	<br>
	I name the passed in parameter <span class="code">startingPoints</span>.<br>
	I also rename the property to <span class="code">CurrentPoints</span> (and thus the test case) to further clarify the logic:<br>
	<i>starting points is passed into the constructor which sets the current points.</i><br>
	<br>
	I also encapsulate <span class="code">CurrentPoints</span> into a 'getter, private setter'.<br>
	In general I want to <a href="https://medium.com/swlh/the-importance-of-code-encapsulation-ce19efbcfe57">encapsulate</a> the production code as much as possible.<br>
	The only exposed interface should come from<br>
	the requirements that the TDD cycles will drive,<br>
	and if the tests need additional exposure no top of that<br>
	(should be kept to a minimum).
</p>
<pre><code [highlight]="test_1_refactor"></code></pre>
<pre><code [highlight]="impl_1_refactor"></code></pre>

<p>
	From now on the code will mostly be presented as a part of the class,<br>
	focused on the current TDD cycle.<br>
	The code in its entirety and the Unity project is on <a href="https://github.com/EgillAntonsson/tdd-avatar-health-in-unity">GitHub</a>.
</p>

<h2>Handle invalid <span class="code">StartingPoints</span> values</h2>
<p>
	Now it comes to mind that invalid values can be passed in,<br>
	as our avatar should never start with less than 1 points<br>
	(because otherwise Link would start up being dead :P ).<br>
	Thus I'll throw an exception when the value is invalid.<br>
	<span class="outOfScope">Invalid values should also be handled where they are defined,<br>
		in the previously mentioned game balancing config.</span>
</p>

<h3><span class="redFail">RED</span></h3>

<pre><code [highlight]="test_2_Red"></code></pre>

<p>
	I deem I can use existing <span class="code">ArgumentOutOfRangeException</span> from <span class="code">System</span><br>
	if I include an informative message for my case.<br>
	I chose the value <code>0</code> as it's on the edge of invalidation (as <code>1</code> is valid).<br>
	<br>
	I'm asserting that the exception message only contains <i>invalid</i> (ignoring case)<br>
	which should be the 'keyword' in the message.<br>
	I don't want to assert the full message as that would make the test fragile,<br>
	e.g. the test would fail when a dev tweaks the wording of the message (although keeping the keyword).<br>
	<br>
	Elaborating further on my test case naming convention, I use my template:<br><br>
	<i>[exit point]</i> or <i>[expected behavior of Unit of Work]</i><br>
	then adding <i>_When[Scenario]</i> for other scenarios than the basic scenario.<br><br>
	which translates to the two test cases:<br>
	<code>ThrowsError_WhenStartingPointsIsInvalid</code><br>
	<code>CurrentPointsHasStartingValue</code>
</p>

<h3><span class="greenPass">GREEN</span></h3>

<pre><code [highlight]="impl_2_Green"></code></pre>

<p>
	I'm confident that the implementation of the conditional<br>
	is the proper generic solution for this requirement.<br>
	However I just did the bare minimum for the exception message,<br>
	and I will refactor it in the next step.<br>
</p>

<h3><span class="greenRefactor">REFACTOR</span></h3>

<pre><code [highlight]="impl_2_Refactor"></code></pre>
<p>
	To make the message more informative.<br>
	I define the variable <code>lowestValidValue</code><br>
	to make sure the conditional and the exception message are in-sync.<br>
	I get the name of the sent in parameter with <code>nameof(startingPoints)</code>.<br>
	<br>
	I check the message in TestRunner by temporarily commenting out<br>
	all lines in the test except the constructor invocation.<br>
	The message displays when value <code>0</code> was passed in:<br>
	<code>System.ArgumentOutOfRangeException : Value '0' is invalid, it should be equal or higher than '1'<br>
		Parameter name: startingPoints</code>
</p>

<h2>Let's test a few more values</h2>

<p>I'm confident that the implementation of the requirement<br>
	will work for any passed-in parameter value.<br>
	But I'll test a few more values to verify it,<br>
	and to demonstrate how to do it in a clean and maintainable way.
</p>

<h3><span class="greenRefactor">REFACTOR</span></h3>

<p>Refactoring the tests to add test cases<br>
	where the value is close to the valid or invalid edge,<br>
	using <a href="https://docs.nunit.org/articles/nunit/technical-notes/usage/Parameterized-Tests.html">Parameterized Tests</a> with inline <a href="https://docs.nunit.org/articles/nunit/writing-tests/attributes/testcase.html">TestCase</a> attribute.
</p>
<pre><code [highlight]="test_3_Green"></code></pre>

<p>
	This runs in total 4 test cases and Unity Test Runner looks like this:
</p>

<figure>
	<img src="../assets/images/blog/tdd/TestRunner_tests-using-TestCase.PNG" alt="Unity Test Runner: tests using TestCase attribute" title="Unity Test Runner: tests using TestCase attribute" class="imageSmallText">
	<figcaption>
		Unity Test Runner: tests using <i>TestCase</i> attribute
	</figcaption>
</figure>
