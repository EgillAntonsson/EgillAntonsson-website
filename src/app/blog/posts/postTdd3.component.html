<h1>{{post.seriesTitle}}</h1>
<h2>{{post.title}}</h2>
<div class="byAndDate">
	<small>by Egill Antonsson, published on {{post.dateYear}} {{post.dateMonth}} {{post.dateDay}}</small>
</div>

<h2>Setting up Unity</h2>
<p>
	A new Unity project has by default the <i>Test Framework</i> package installed (current version 1.1.30).<br>
	Its <a href="https://docs.unity3d.com/Packages/com.unity.test-framework@1.1/manual/index.html">documentation</a> details how setup tests for a project.<br>
	I'm currently using  Unity version 2020.3.24f1, and run the tests via the Unity Test Runner.<br>
	My project structure starts very simple:
</p>
	<ul>
		<li>The test code is in: <i>Assets/Tests/EditMode/[ClassName]Test.cs</i></li>
		<li>The production code is in: <i>Assets/Scripts/Runtime/[ClassName].cs</i></li>
	</ul>
<p>
	As the folder structure implies, I'm doing <i>EditMode</i> tests for the production <i>Runtime</i> code<br>
	<i>EditMode</i> test have access to the <i>Editor</i> code (only about extending the editor)<br>
	in addition to the <i>Runtime</i> code (the runtime of the target platform, e.g iOS).<br>
	My main reason to prefer <i>EditMode</i> tests for <i>Runtime</i> code,<br>
	is that <i>PlayMode</i> tests take longer to run<br>
	(as the startup and initialization of the player in the editor takes some time).<br>
	Also, the domain and other logic does not need the <i>PlayMode</i> tests features<br> (tests can run as coroutine to step through Unity specific code).<br>
	The documentation page <a href="https://docs.unity3d.com/Packages/com.unity.test-framework@1.1/manual/edit-mode-vs-play-mode-tests.html">EditMode vs. PlayMode tests</a> explains their difference further.

<h2>The first requirement</h2>
<p>
	Let's look closer to the <i>definition and start state</i> from the user perspective:
</p>
<ul>
	<li>The Life Gauge measures Link's current amount of health</li>
	<li>Health is visually represented in the form of Hearts, and they are in fractions of four</li>
	<li>The Life Gauge starts with 3 Hearts</li>
</ul>
<p>
	Let's filter and transform this into a requirement that's focused only on the domain logic<br>
	(as visual representation will be done later):
</p>
<ul>
	<li>Avatar Health starts with 12 Health Points (equals to visual representation of 3 Hearts * 4 Fractions)</li>
</ul>
<p>
</p>

<h2>Health Points starting value</h2>

<h3><span class="redFail">RED</span></h3>
<p>
	I define the test class and the first test.<br>
	I start focusing on <span class="code">Health</span> class implementation.<br>
	(which in the end will likely be associated with an <span class="code">Avatar</span> class).<br>
	The test is failing as the code does not even compile.
</p>
<pre><code [highlight]="test_1_Red"></code></pre>
<p>
	I'm trying out a new naming/structuring convention for the tests that I recently discovered from<br>
	Charles Amat via <a href="http://infalliblecode.com/unity-tdd-1/">TDD in Unity - Part 1</a> that references<br>
	Erik Dietrich via <a href="https://daedtech.com/tdd-and-modeling-a-chess-game/">TDD and modeling a chess game</a> that references<br>
	Phil Haack via <a href="https://haacked.com/archive/2012/01/02/structuring-unit-tests.aspx/">Structuring Unit Tests</a> that references 3 other guys...
</p>

<h3><span class="greenPass">GREEN</span></h3>
<p>Let's make the test pass with a simple implementation.
</p>
<pre><code [highlight]="impl_1_Green"></code></pre>

<h3><span class="greenRefactor">REFACTOR</span></h3>

<p>Now it comes to mind that from a game design perspective,<br>
	it is good to be able to tweak the starting health points for game balancing,<br>
	thus I refactor the value to be passed as parameter into the constructor.<br>
	<span class="outOfScope">An advanced system would have an accessible game balancing config that's integrated into the code base,<br>
	that would then use <span class="code">Health</span> class as designed (passing in value/s).<br>
	I might later decide to implement a very simplified game balancing config and integration.</span><br>
	<br>
	I name the passed in parameter <span class="code">startingPoints</span>.<br>
	I also rename the property to <span class="code">CurrentPoints</span> to further clarify the logic:<br>
	<i>starting points is passed into the constructor which sets the current points.</i><br>
	<br>
	I also encapsulate <span class="code">CurrentPoints</span> with a private setter,<br>
	as I want to <a href="https://medium.com/swlh/the-importance-of-code-encapsulation-ce19efbcfe57">encapsulate</a> the production code as much as possible.<br>
	The only exposure should be for the class interface that other production code will use and the tests<br>
	(though no or minimal exposure should be only for the tests).<br>
	The requirements and the TDD will gradually expose the required and proper interface.
</p>
<pre><code [highlight]="code_1_Refactor"></code></pre>

<h2>Handle invalid <span class="code">StartingPoints</span> values</h2>
<p>
	Now it comes to mind that invalid <span class="code">StartingPoints</span> values can be passed in,<br>
	as our avatar should never start with less than 1 points,<br>
	(because otherwise Link would start up being dead :P ).<br>
	Thus I'll throw an exception when the value is invalid.<br>
	<span class="outOfScope">Invalid values should also be handled where they are defined<br>
	(in the previously mentioned game balancing config).<br></span>
</p>

<h3><span class="redFail">RED</span></h3>

<pre><code [highlight]="test_2_Red"></code></pre>

<p>
	I deem I can use existing <span class="code">ArgumentOutOfRangeException</span> from namespace <span class="code">System</span><br>
	if I include an informative message for my case.<br>
	<br>
	I chose the value 0 as it's on the edge of invalidation (as 1 is valid).
</p>

<h3><span class="greenPass">GREEN</span></h3>

<pre><code [highlight]="impl_2_Green"></code></pre>

<p>The implementation of the conditional '<span class="code" [highlight]="'if (startingPoint < 1)'"></span>'<br>
	was easy to come up with, and is also the proper generic solution for this requirement.<br>
	<br>
	The message of the thrown exception would be (if value 0 was passed in):<br>
	<i>System.ArgumentOutOfRangeException : Value '0' is invalid, it should be higher than '0'<br>
		Parameter name: startingPoints</i><br>
	<br>
	I feel that no refactoring is needed in this cycle,<br>
	as I did both <span class="greenPass">GREEN</span> and <span class="greenRefactor">REFACTOR</span> in one step, for both the conditional and the thrown exception.<br>
	Overall the code looks clean, so moving on.
</p>

<h2>Let's test a few more values</h2>

<p>As the implementation is very simple I am confident that it's<br>the proper generic solution that works for any passed-in value.<br>
	But let's test a few more values to demonstrate how to do it in a clean and maintainable way.
</p>

<h3><span class="greenRefactor">REFACTOR</span></h3>

<p>Refactoring the tests to add test cases where the value is close to the valid/invalid edge,<br>
	using <a href="https://docs.nunit.org/articles/nunit/technical-notes/usage/Parameterized-Tests.html">Parameterized Tests</a> with inline <a href="https://docs.nunit.org/articles/nunit/writing-tests/attributes/testcase.html">Test Case</a> attribute.
</p>
<pre><code [highlight]="test_3_Green"></code></pre>

<p>
	This runs in total 4 test cases and Unity Test Runner looks like this (menu item <i>Window > General > Test Runner</i>):
</p>

<figure>
	<img src="../assets/images/blog/tdd/HealthTest-using-TestCase.PNG" alt="Unity Test Runner: HealthTest using TestCase" title="Unity Test Runner: HealthTest using TestCase attribute" class="image">
	<figcaption>
		Unity Test Runner: <i>HealthTest</i> using <i>TestCase</i> attribute
	</figcaption>
</figure>

<h2>Concluding this part</h2>

<p>This concludes the first requirement and this part.<br>
	I aim to continue with the requirements and the implementation in later blog posts.
</p>
